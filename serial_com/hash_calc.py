# -*- coding: utf-8 -*-

# region Description
"""
hash_calc.py: Password verification by calculating PMKID or MIC from target access point
Author: johndeweyzxc (johndewey02003@gmail.com)
"""
# endregion

import hmac
import hashlib
from hashlib import pbkdf2_hmac
from binascii import a2b_hex, hexlify

OUT_GREEN = "\033[92m"
OUT_RED = "\033[91m"
COLOR_RESET = "\033[0m"


def prf512(key, a, b):
    """ The PRF512 function is used to compute four 128-bit keys (KCK, KEK, TK1, TK2) """

    blen = 64
    i = 0
    R = b''
    while i <= ((blen * 8 + 159) / 160):
        hmacsha1 = hmac.new(key, a + chr(0x00).encode() +
                            b + chr(i).encode(), hashlib.sha1)
        i += 1
        R = R + hmacsha1.digest()
    return R[:blen]


def calculate_pmk(psk, ssid) -> bytes:
    """
    PMK (Pairwise Master Key):

    PMK resides on all stations as in AP and client devices, so we do not need to share 
    this information. We use this information to create PTK which are used for unicast 
    data encryption.

    PMK = PBKDF2_HMAC('sha1', PSK, SSID, iteration, output size in bytes)
    """
    pbkdf2 = pbkdf2_hmac('sha1', psk.encode('utf-8'),
                         ssid.encode('utf-8'), 4096, 32)
    pmk_str = hexlify(pbkdf2)
    # print(f"PMK: {pmk_str.decode('ascii').upper()}")
    return pbkdf2


def calculate_ptk(psk, ssid, bssid, sta_mac, snonce, anonce) -> bytes:
    """
    PTK (Pairwise Transient Key):

    Pairwise Transient key is used to encrypt all unicast traffic between a client station 
    and the access point. PTK is unique between a client station and access point. To 
    generate PTK, client device and access point need the following information. PTK is 
    dependent on another high-level key PMK.

    PTK = PRF512(PMK, b"Pairwise key expansion", min_max(BSSID, STA_MAC) + min_max(Anonce, Snonce))
    """
    a = b'Pairwise key expansion'
    min_max_mac = min(a2b_hex(bssid), a2b_hex(sta_mac)) + \
        max(a2b_hex(bssid), a2b_hex(sta_mac))
    # print(f"MIN_MAX_MAC: {hexlify(min_max_mac)}")

    min_max_nonce = min(a2b_hex(anonce), a2b_hex(snonce)) + \
        max(a2b_hex(anonce), a2b_hex(snonce))
    # print(f"MIN_MAX_NONCE: {hexlify(min_max_nonce)}")

    b = min_max_mac + min_max_nonce
    # print(f"a: {hexlify(a)}")
    # print(f"b: {hexlify(b)}")
    pmk = calculate_pmk(psk, ssid)
    ptk = prf512(pmk, a, b)
    # print(f"PTK: {hexlify(ptk).decode('ascii').upper()}")
    return ptk


def calculate_pmkid(pmkid, psk, ssid, bssid, sta_mac) -> bool:
    """
    PMKID is a unique identifier that helps facilitate the secure exchange of authentication 
    and encryption keys between a client device and an access point during the initial 
    connection setup.

    The PMKID is computed by using HMAC-SHA1 where the key is the PMK and the data part is 
    the concatenation of a fixed string label "PMK Name", the access point's MAC address 
    and the station's MAC address.

    PMKID = HMAC_SHA1_128(PMK, b"PMK Name" | MAC_AP | MAC_STA)
    """

    pmk = calculate_pmk(psk, ssid)
    message = b'PMK Name' + a2b_hex(bssid) + a2b_hex(sta_mac)
    # print(f"message: {hexlify(message)}")
    calculated_pmkid = hmac.new(pmk, message, hashlib.sha1)

    # print(f"PMKID: {calculated_pmkid.hexdigest()[0:32].upper()}")
    if calculated_pmkid.hexdigest()[0:32].upper() == pmkid:
        """
        The calculated PMKID and the provided PMKID matched which means the output from the
        launcher and the launcher itself is working as expected
        """

        # print(f"{OUT_GREEN}PMKID MATCHED!{COLOR_RESET}")
        return True
    else:
        # print(f"{OUT_RED}PMKID NOT MATCHED!{COLOR_RESET}")
        return False


def calculate_mic(psk, ssid, anonce, snonce, bssid, sta_mac, message_2_data, mic) -> bool:
    """
    MIC (Message Integrity Code)

    The MIC in the 4-way handshake serves as a form of cryptographic integrity protection. 
    It is a code generated by encrypting a portion of the handshake messages with the PTK. 
    The purpose of the MIC is to verify the integrity of the handshake messages, ensuring 
    that they have not been tampered with or altered during transmission.

    MIC = HMAC_SHA1_128(PTK, message 2 authentication data)

    The message 2 authentication data is the data that is captured in the second message of 
    the 4-way handshake.
    """
    ptk = calculate_ptk(psk, ssid, bssid, sta_mac, snonce, anonce)
    calculated_mic = hmac.new(ptk[0:16], a2b_hex(message_2_data), hashlib.sha1)

    # print(f"MIC: {calculated_mic.hexdigest()[:32].upper()}")
    if calculated_mic.hexdigest()[:32].upper() == mic:
        """
        The calculated MIC and the provided MIC matched which means the output from the
        launcher and the launcher itself is working as expected
        """

        # print(f"{OUT_GREEN}MIC MATCHED!{COLOR_RESET}")
        return True
    else:
        # print(f"{OUT_RED}MIC NOT MATCHED!{COLOR_RESET}")
        return False


# calculate_pmkid(pmkid, psk, ssid, bssid, sta_mac)

# calculate_mic(psk, ssid, anonce, snonce, bssid, sta_mac, m2_data, mic)
